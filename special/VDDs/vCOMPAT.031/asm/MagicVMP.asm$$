; --------------------------------------------------------------------------

Public MagicVMP_SearchSignature           ;
Public MagicVMP_SearchSignatureInSel      ;
Public MagicVMP_ApplyPatch                ;
Public MagicVMP_DoAntiCLI                 ;

Comment *컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 Routine:  Processes AreaPtr[AreaLength] with MagicData-Signature Data
 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴*
MagicVMP_SearchSignature       Proc Near    Uses ecx esi edi, MagicDataPtr:dword, AreaPtr:dword, AreaLength:dword
   mov     esi, MagicDataPtr
   mov     edi, AreaPtr
   lodsd                                  ; EAX - Magic-DWORD
   add     esi, 4                         ; ESI - To actual Pattern-Start
   mov     ecx, 4                         ; 4x DWORD Steps
  MagicSearchLoop:
   MPush   <ecx,edi>
      mov      ecx, AreaLength
      shr      ecx, 2                  ; ECX = Length/4
     ContinueMagicSearch:
      repne    scasd
      jne      MagicDWordNotFound
      ; We found the magic DWord, so process further...
      MPush    <ecx,esi,edi>
         add      edi, ds:[esi-4]      ; EDI = EDI+MagicOffset
        PatternSearchLoop:
         movzx    ecx, byte ptr ds:[esi]
         inc      esi                  ; ECX - Pattern-Length
         repe     cmpsb
         jne      PatternFailed
         movzx    ecx, byte ptr ds:[esi]
         inc      esi
         or       ecx, ecx
         jz       PatternDone
         add      edi, ecx
         jmp      PatternSearchLoop

        PatternDone:
      MPop     <edi,esi>
      mov      eax, edi
      MPop     <ecx,edi,ecx>
      sub      eax, 4                     ; Now pointer to Magic-DWORD
      ret

        PatternFailed:
      MPop     <edi,esi,ecx>
      or       ecx, ecx
      jnz      ContinueMagicSearch
     MagicDWordNotFound:
   MPop     <edi,ecx>
   inc      edi
   dec      ecx
   jnz      MagicSearchLoop
   xor      eax, eax
   ret
MagicVMP_SearchSignature        EndP

Comment *컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 Routine: Searches through some of the available selectors from LDT
           We are not using a table in here, but we are "guessing" the
           selectors based on type and size. We only search code-selectors
           The caller may specify a maximum size.
 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴*
MagicVMP_SearchSignatureInSel  Proc Near    Uses ebx ecx edx esi edi, MagicDataPtr:dword, MaxSize:dword
   mov      ecx, CodeSelectorCount
   or       ecx, ecx
   jz       Done
   

   mov      ebx, 0EFh                    ; First selector in VDMs
  SelectorLoop:
      lar      eax, ebx                  ; EAX - Type of selector
      jz       GotSelector               ; Zero flag set, if valid selector
  NextSelector:
   add      ebx, 8
   cmp      ebx, 2000
   jb       SelectorLoop
   xor      eax, eax                     ; Nothing found, so reply NULL
   ret

  GotSelector:
   and      eax, 1800h
   cmp      eax, 1800h                   ; Application Code?
   jne      NextSelector                 ; No -> go to next selector
   lsl      ecx, ebx                     ; ECX - Size of Selector
   cmp      ecx, MaxSize                 ; Is too big?
   ja       NextSelector                 ; Yes -> go to next selector
   push     ecx
      push     ebx
      push     offset TempDWord
      call     VDHGetSelBase
   pop      ecx
   or       eax, eax
   jz       NextSelector
   push     ecx
   push     TempDWord
   push     MagicDataPtr
   call     MagicVMP_SearchSignature     ; Search through this selector...
   add      esp, 12
   or       eax, eax
   jz       NextSelector
   ret
MagicVMP_SearchSignatureInSel  EndP

Comment *컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 Routine:  Patches [SignaturePtr] with MagicPatch
 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴*
MagicVMP_ApplyPatch            Proc Near    Uses ecx esi edi, MagicPatchPtr:dword, SignaturePtr:dword
   mov      esi, MagicPatchPtr
   mov      edi, SignaturePtr
  PatchApplyLoop:
      movzx    ecx, byte ptr ds:[esi]
      inc      esi
      rep      movsb
      movzx    ecx, byte ptr ds:[esi]
      inc      esi
      add      edi, ecx
      or       ecx, ecx
      jnz      PatchApplyLoop
   ret
MagicVMP_ApplyPatch            EndP

Comment *컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
 Routine:  Searches and patches out infamous CLI-bug. Uses SelectorTable[]
 컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴*
MagicVMP_DoAntiCLI              Proc Near    Uses ecx esi es edi
   ; We go through all Memory-Blocks that are larger than 64k and search for
   ;  CLI opcode (FAh). If it gets found, we check if the surround data seems
   ;  to be CPU opcodes and in that case, we will patch it to STI (FBh)
   cmp     PropertyDPMIAntiCLI, 0           ; Are we active?
   je      Done
   mov     ax, ds
   mov     es, ax                        ; ES==DS
   mov     esi, offset MemoryBlocks
  SelectorLoop:
      test    [esi+MemoryBlockStruc.Flags], 00000001b
      jz      NoProcessing
      xor     [esi+MemoryBlockStruc.Flags], 00000001b ; Remove flag
      mov     ecx, [esi+MemoryBlockStruc.BlockLength]
      cmp     ecx, 65536                 ; Block smaller than 64k? -> skip
      jb      NoProcessing
      mov     edi, [esi+MemoryBlockStruc.LinearAddress]
      add     edi, 50                    ; Dont begin at boundary
      sub     ecx, 100                   ; Dont end at boundary
      cmp     ecx, 400000h
      jbe     CLIsearchLoop
      mov     ecx, 400000h

     CLIsearchLoop:
         mov     al, 0FAh                ; The bad-ass 'CLI' opcode
         repne   scasb                   ; Start Compare...
         jne     NoProcessing            ; ...nothing found
      call    MagicVMP_AnalyseCLI        ; Check data for opcode-signatures
      jc      CLIsearchLoop
      ; We are now patching with STI...
      mov     bptr es:[edi-1], 0FBh
      jmp     CLIsearchLoop

  NoProcessing:
   add     esi, MemoryBlockStrucLen
   cmp     esi, offset MemoryBlocksEnd
   jb      SelectorLoop
  Done:
   ret
MagicVMP_DoAntiCLI              EndP

;        In: DS/ES:EDI - Pointer behind assumed CLI-opcode
;       Out: Carry set, if pointer is assumed to be data/non-CLI-opcode
; Destroyed: *none*
;
;      From: Internal Usage
;   Context: task
;  Function: Checks a given location to point to the x86-opcode "CLI". This is
;             somewhat magic code, as it checks various signatures with the
;             surround bytes. There may be false alarms and this routine
;             possibly needs some tweaking.
MagicVMP_AnalyseCLI             Proc Near    Uses edi
   cmp     wptr es:[edi-3], 589Ch        ; PUSHFD/POP EAX in front of CLI
   je      BasicSignature
   cmp     wptr es:[edi-3], 21CDh        ; INT 21h in front of CLI
   je      BasicSignature
   cmp     bptr es:[edi-2], 9Ch          ; PUSHFD in front of CLI
   je      BasicSignature
   stc                                   ; No basic signature found...
   ret

  BasicSignature:
      call    MagicVMP_IdentifyOpCode
      jc      DontPatch
   cmp     bptr es:[edi], 0C2h           ; RETN [xx]
   je      GoPatch
   cmp     bptr es:[edi], 0CFh           ; IRET
   je      GoPatch
   cmp     bptr es:[edi], 0C3h           ; RETN
   jne     BasicSignature
  GoPatch:
   clc
   ret

  DontPatch:
;   int 3
   stc
   ret
MagicVMP_AnalyseCLI             EndP

;        In: DS/ES:EDI - Pointer to assumed opcode location
;       Out: EDI       - Pointer behind opcode
;             or carry set, if pointer does not point to opcode (EDI destroyed)
; Destroyed: *none*
;
;      From: Internal Usage
;   Context: task
;  Function: Checks given for a valid x86-opcode. Some opcodes are not checked
;             for because they are reserved for OS or are meant for coprocessor
MagicVMP_IdentifyOpCode        Proc Near    Uses eax ebx ecx edx
   mov     ebx, offset MagicOpCode_Begin
   xor     eax, eax
   xor     ecx, ecx
   xor     edx, edx
  IdentifyLoop:
      movzx   dx, bptr es:[edi]
      inc     edi
      add     ebx, edx
      mov     al, bptr ds:[ebx]
      mov     ah, al
      and     al, 0Fh
      shr     ah, 4                      ; AH - Upper 4 bits, AL - Lower 4 bits
      add     cl, ah
      cmp     al, 0Fh                    ; Jump-To 0Fh? -> We are done
      je      EndOfOpCode
      mov     dl, al
      shl     dx, 2                      ; DX = DX*4
      mov     ebx, [MagicOpCode_JumpTable+edx]
      jmp     IdentifyLoop

  EndOfOpCode:
   cmp     ah, 0Fh
   je      BadOpCode
   add     edi, ecx
   clc
   ret

  BadOpCode:
;   int 3
   stc
   ret
MagicVMP_IdentifyOpCode        EndP
