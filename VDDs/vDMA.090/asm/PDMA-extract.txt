





   ; This is called directly, when Rape-Fill is deactivated or only one Copy
   ;  action is required under Rape-Fill. We check for overflow anytime just to
   ;  circumvent any errors and prevent buffer overflows in any case.
  SingleCopy:
   cmp     ecx, edx                      ; Compare Length with Length Till EOB
   jb      EnoughBytesLeft
   mov     cx, [esi+PDMAslotStruc.TransferLength]
   sub     cx, [esi+PDMAslotStruc.CopyPos] ; ECX - Length (DMA) till EOB
   ; Also set Terminal-Count, because we reached EOB
   or      [esi+PDMAslotStruc.Flags], PDMAslot_Flags_TerminalCount
   ; Reset LastVirtLength only, when being not in Rape-Fill mode
   test    [esi+PDMAslotStruc.Flags], PDMAslot_Flags_RapeFill
   jnz     BeingRapeFill
   mov     [esi+PDMAslotStruc.LastVirtLength], 0FFFFh
  BeingRapeFill:

  EnoughBytesLeft:





   Flags           db ?         ; Bit 0   - Channel Enabled
                                ; Bit 1   - Gets VDMA CallOuts
                                ; Bit 2   - Timed Call Back used
                                ; Bit 3   - Rape-Fill (special DMA-method)
                                ; Bit 4   - InCopyEvent (Timed Call Back!)
                                ; Bit 5   - Terminal Count experienced
   Mode            db ?         ; Bit 0-1 - Transfer Type
                                ; Bit 2   - Auto-Init Mode
                                ; Bit 3   - Address decrement
                                ; Bit 4-5 - Transfer Mode
   PhysicalAddress dd ?         ; Physical Buffer of actual DMA-buffer
                                ;  This is the *DMA* Physical Address
                                ;  On 16-bit DMA this will be the WORD address!
   PhysicalEnd     dd ?         ; Physical Ptr to end of Buffer
   LinearAddress   dd ?         ; Linear address of actual DMA-buffer
   VirtualAddress  dd ?         ; Virtual address of VDM-buffer (application)
   TransferLength  dw ?         ; DMA-Length of Block at VirtualAddress
   CurLength       dw ?         ; DMA-CurLength (contains left transfer)
   LastVirtLength  dw ?         ; Virtual CurLength known to VDM
   PhysicalLength  dd ?         ; Physical Length of Block (Byte-Length)
   OwnedBy         dd ?         ; VDM-Handle of Session that owns this DMA-Slot
   ContextHookHndl dd ?         ; Context-Hook-Handle for CopyEvent
   TriggerPos      dw ?         ; Used for Timed-Copy (detailed in TIMEDDMA.txt)
   TriggerDistance dw ?         ; ditto
   CopyPos         dw ?         ; ...
   BlockLength     dw ?         ; ...
   LastBlockLength dw ?         ; ...




   ; We were executed by a trigger...
   movzx   eax, [esi+PDMAslotStruc.CopyPos]
   mov     edx, eax                      ; EDX - CopyPos (in DMA form)
   ; Find out, if we have to process Last-Block...
   movzx   ecx, [esi+PDMAslotStruc.LastBlockLength]
   add     eax, ecx                      ; EAX - End-Pos of LastBlock-Copy...
   cmp     ax, [esi+PDMAslotStruc.TransferLength]
   jae     IsLastBlock
   mov     cx, [esi+PDMAslotStruc.BlockLength] ; use normal block length...
  IsLastBlock:
   ; (E)CX - BlockLength in DMA format, (E)DX - CopyPos in DMA format
   inc     ecx                           ; EDX stays at 0 (cause its an offset)
   ; Check, if we violate the boundary...
   mov     bx, [esi+PDMAslotStruc.TransferLength]
   sub     bx, ax
   jnc     SingleCopy
   sub     cx, bx
  SingleCopy:
   mov     ebx, ecx                      ; Save BlockLength+1 in EBX
   ; Adjust for 16-bit transfers...
   cmp     [esi+VDMAslotStruc.DMAno], 4
   jb      Is8bitChannel
   shl     edx, 1
   shl     ecx, 1                        ; On 16-bit Channels -> WORD Size
  Is8bitChannel:
   ; ECX - Byte-Length of Block-To-Copy, EDX - Offset into Transfer-Buffer
   ; EBX - DMA-Length of Block-To-Copy
   push    ebx
      mov     eax, [esi+PDMAslotStruc.VirtualAddress] ; Source (VDM)
      add     eax, edx
      push    eax
      mov     eax, [esi+PDMAslotStruc.LinearAddress]  ; Destination (Physical)
      add     eax, edx
      push    eax
      push    ecx                                     ; Length in Bytes
      call    VDHCopyMem
   pop     ebx
   ; EBX - (BlockLength+1) <- this is *NOT* byte-length, but DMA-length (!)
   xor     eax, eax
   mov     dx, [esi+PDMAslotStruc.CopyPos]
   add     dx, bx                ; Adjust CopyPos
   jc      CopyPosOverflow
   cmp     dx, [esi+PDMAslotStruc.TransferLength]
   jb      CopyPosNoOverflow
   ; Report overflow to caller, reset LastVirtLength if not RapeFill and set TC
  CopyPosOverflow:
   inc     eax                   ; EAX==1
   test    [esi+PDMAslotStruc.Flags], PDMAslot_Flags_RapeFill
   jnz     OnRapeFill
   mov     [esi+PDMAslotStruc.LastVirtLength], 0FFFFh
  OnRapeFill:
   or      [esi+PDMAslotStruc.Flags], PDMAslot_Flags_TerminalCount
   xor     dx, dx                ; Reset on overflow to NULL
  CopyPosNoOverflow:
   mov     [esi+PDMAslotStruc.CopyPos], dx

   mov     dx, [esi+PDMAslotStruc.TriggerPos]
   sub     [esi+PDMAslotStruc.TriggerPos], bx
   jnc     TriggerPosNoOverflow
   mov     dx, [esi+PDMAslotStruc.TransferLength]
   mov     [esi+PDMAslotStruc.TriggerPos], dx
  TriggerPosNoOverflow:
   ret                           ; EAX is BOOL that shows if overflow occured














; Is called by PDMA_CopyEvent() to process at least one PCopy-Step.
;  It's also possible that the next trigger is already triggered, so this
;  routine may process multiple PCopy-Steps.
PDMA_ProcessPCopySteps          Proc Near   Uses edx esi, PDMAptr:dword
   mov     esi, PDMAptr
   push    esi
   call    PDMA_ProcessOnePCopyStep      ; One Process any time...
   mov     dx, [esi+PDMAslotStruc.CurLength]
   shl     edx, 16
   mov     dx, ax
  CheckStillTrigger:
      ; Check, if Trigger to activated...
      ror     edx, 16
      cmp     dx, [esi+PDMAslotStruc.TriggerPos]
      ja      NoMoreTrigger
      add     dx, [esi+PDMAslotStruc.TriggerDistance]
      jc      GotTrigger
      cmp     dx, [esi+PDMAslotStruc.TriggerPos]
      jb      NoMoreTrigger
     GotTrigger:
      rol     edx, 16
      push    esi
      call    PDMA_ProcessOnePCopyStep   ; Process it one more time...
      or      dx, dx                        ; If already set -> loop directly
      jnz     CheckStillTrigger
      or      ax, ax                        ; If not set -> loop directly
      jz      CheckStillTrigger
      mov     dx, ax
      jmp     CheckStillTrigger

  NoMoreTrigger:
   shr     edx, 16
   mov     eax, edx                      ; Got EOB/Overflow into EAX
  DoneTriggers:
   ret
PDMA_ProcessPCopySteps          EndP

; Will make one PCopy-Step, will return TRUE, if end-of-buffer reached/overflow
PDMA_ProcessOnePCopyStep        Proc Near   Uses ebx ecx edx esi, PDMAptr:dword
   mov     esi, PDMAptr
   ; We were executed by a trigger...
   movzx   eax, [esi+PDMAslotStruc.CopyPos]
   mov     edx, eax                      ; EDX - CopyPos (in DMA form)
   ; Find out, if we have to process Last-Block...
   movzx   ecx, [esi+PDMAslotStruc.LastBlockLength]
   add     eax, ecx                      ; EAX - End-Pos of LastBlock-Copy...
   cmp     ax, [esi+PDMAslotStruc.TransferLength]
   jae     IsLastBlock
   mov     cx, [esi+PDMAslotStruc.BlockLength] ; use normal block length...
  IsLastBlock:
   ; (E)CX - BlockLength in DMA format, (E)DX - CopyPos in DMA format
   inc     ecx                           ; EDX stays at 0 (cause its an offset)
   ; Check, if we violate the boundary...
   mov     bx, [esi+PDMAslotStruc.TransferLength]
   sub     bx, ax
   jnc     SingleCopy
   sub     cx, bx
  SingleCopy:
   mov     ebx, ecx                      ; Save BlockLength+1 in EBX
   ; Adjust for 16-bit transfers...
   cmp     [esi+VDMAslotStruc.DMAno], 4
   jb      Is8bitChannel
   shl     edx, 1
   shl     ecx, 1                        ; On 16-bit Channels -> WORD Size
  Is8bitChannel:
   ; ECX - Byte-Length of Block-To-Copy, EDX - Offset into Transfer-Buffer
   ; EBX - DMA-Length of Block-To-Copy
   push    ebx
      mov     eax, [esi+PDMAslotStruc.VirtualAddress] ; Source (VDM)
      add     eax, edx
      push    eax
      mov     eax, [esi+PDMAslotStruc.LinearAddress]  ; Destination (Physical)
      add     eax, edx
      push    eax
      push    ecx                                     ; Length in Bytes
      call    VDHCopyMem
   pop     ebx
   ; EBX - (BlockLength+1) <- this is *NOT* byte-length, but DMA-length (!)
   xor     eax, eax
   mov     dx, [esi+PDMAslotStruc.CopyPos]
   add     dx, bx                ; Adjust CopyPos
   jc      CopyPosOverflow
   cmp     dx, [esi+PDMAslotStruc.TransferLength]
   jb      CopyPosNoOverflow
   ; Report overflow to caller, reset LastVirtLength if not RapeFill and set TC
  CopyPosOverflow:
   inc     eax                   ; EAX==1
   test    [esi+PDMAslotStruc.Flags], PDMAslot_Flags_RapeFill
   jnz     OnRapeFill
   mov     [esi+PDMAslotStruc.LastVirtLength], 0FFFFh
  OnRapeFill:
   or      [esi+PDMAslotStruc.Flags], PDMAslot_Flags_TerminalCount
   xor     dx, dx                ; Reset on overflow to NULL
  CopyPosNoOverflow:
   mov     [esi+PDMAslotStruc.CopyPos], dx

   mov     dx, [esi+PDMAslotStruc.TriggerPos]
   sub     [esi+PDMAslotStruc.TriggerPos], bx
   jnc     TriggerPosNoOverflow
   mov     dx, [esi+PDMAslotStruc.TransferLength]
   mov     [esi+PDMAslotStruc.TriggerPos], dx
  TriggerPosNoOverflow:
   ret                           ; EAX is BOOL that shows if overflow occured
PDMA_ProcessOnePCopyStep      EndP
