
Public PDMA_IsInUse
Public PDMA_DoWeOwnChannel
Public PDMA_SetPDMAslot
Public PDMA_StartTransfer
Public PDMA_StopTransfer
Public PDMA_CalcTimedTo2Buffers
Public PDMA_CalcTimedTo4Buffers
Public PDMA_CalcTimedToBestFit
Public PDMA_ProcessOnePCopyStep

Public VDHCallOutDMA
Public PDMA_StartVTIMERCallOut
Public PDMA_StopVTIMERCallOut

; -----------------------------------------------------------------------------

; Checks, if the specified physical DMA channel is currently in use...
PDMA_IsInUse                    Proc Near   Uses edx esi, PDMAptr:dword
   mov     esi, PDMAptr
   movzx   dx, [esi+PDMAslotStruc.PortWriteMasks]
   in      al, dx
   and     al, [esi+PDMAslotStruc.DMAbitMask] ; Check, if channel masked
   jnz      IsInactive                   ; If Mask is not set or...
   pushf
      cli
      movzx   dx, [esi+PDMAslotStruc.PortFlipFlop]
      out     dx, al                     ; Reset Flip-Flop
      movzx   dx, [esi+PDMAslotStruc.PortLength]
      in      al, dx
      mov     ah, al
      in      al, dx                     ; AX - DMA-CurPos (Low/High exchanged)
   popf
   cmp     ax, 0FFFFh                    ; CurPos is not 0FFFFh...
   je      IsInactive
   mov     eax, 1
   ret
  IsInactive:
   xor     eax, eax
   ret
PDMA_IsInUse                    EndP

; Checks, if the specified physical DMA channel is (still) owned by us...
PDMA_DoWeOwnChannel             Proc Near   Uses edx esi, PDMAptr:dword
   xor     eax, eax                      ; Reset EAX
   mov     esi, PDMAptr
   movzx   dx, [esi+PDMAslotStruc.PortPage]
   in      al, dx
   shl     eax, 8
   pushf
      cli
      movzx   dx, [esi+PDMAslotStruc.PortFlipFlop]
      out     dx, al                     ; Reset Flip-Flop
      movzx   dx, [esi+PDMAslotStruc.PortAddress]
      in      al, dx
      shl     eax, 8
      in      al, dx
   popf
   xchg    al, ah
   ; Now we got the current address in EAX
   cmp     eax, [esi+PDMAslotStruc.PhysicalAddress]
   jb      PDMADWOC_NoOwnage
   cmp     eax, [esi+PDMAslotStruc.PhysicalEnd]
   jae     PDMADWOC_NoOwnage
   mov     eax, 1
   ret
  PDMADWOC_NoOwnage:
   xor     eax, eax
   ret
PDMA_DoWeOwnChannel             EndP

; Will copy mode/address/length/owner from VDMA-Slot to PDMA-Slot
PDMA_SetPDMAslot                Proc Near   Uses ebx esi edi, PDMAptr:dword, VDMAptr:dword
   mov     esi, VDMAptr
   mov     edi, PDMAptr
   mov     al, [esi+VDMAslotStruc.Mode]
   mov     [edi+PDMAslotStruc.Mode], al
   mov     eax, [esi+VDMAslotStruc.BaseAddress]
   cmp     [esi+VDMAslotStruc.DMAno], 4  ; On 16-bit Channels ->
   jb      Is8bitChannel                 ;  BaseAddress consists of a WORD
   mov     ebx, eax                      ;  offset, so isolate and add it again
   and     ebx, 0FFFFh                   ;  making a normal physical address
   and     eax, 0FFFEFFFFh
   add     eax, ebx
  Is8bitChannel:
   mov     [edi+PDMAslotStruc.VirtualAddress], eax
   movzx   eax, [esi+VDMAslotStruc.TransferLength]
   mov     [edi+PDMAslotStruc.TransferLength], ax
   ; Calculate real physical length out of DMA-Length
   inc     eax                           ; DMA will transfer at least 1 byte
   cmp     [esi+VDMAslotStruc.DMAno], 4
   jb      Is8bitChannel2
   shl     eax, 1                        ; On 16-bit Channels -> WORD Size
  Is8bitChannel2:
   mov     [edi+PDMAslotStruc.PhysicalLength], eax

   mov     eax, dword ptr MyVDMHandle
   mov     [edi+PDMAslotStruc.OwnedBy], eax ; Now owned by this VDM
   ret
PDMA_SetPDMAslot                EndP

; Actually starts a physical DMA transfer...
PDMA_StartTransfer              Proc Near   Uses ebx edx esi, PDMAptr:dword
   mov     esi, PDMAptr
   movzx   dx, [esi+PDMAslotStruc.PortMask]
   mov     al, 4
   add     al, bl
   out     dx, al                        ; Mask Channel for safety reasons
   ; No interruption during DMA Startup
   pushf
      cli
      mov     bl, [esi+PDMAslotStruc.DMAmask]
      movzx   dx, [esi+PDMAslotStruc.PortFlipFlop]
      xor     al, al
      out     dx, al                     ; Reset Flip-Flop

      movzx   dx, [esi+PDMAslotStruc.PortMode]
      mov     al, [esi+PDMAslotStruc.Mode]
      shl     al, 2
      add     al, bl
      out     dx, al                     ; Set DMA-Mode

      mov     eax, [esi+PDMAslotStruc.PhysicalAddress]
      cmp     [esi+PDMAslotStruc.DMAno], 4  ; On 16-bit Channels ->
      jb      Is8bitChannel                 ;  Offset is a WORD offset, Page
      mov     edx, eax                      ;  has to stay as it is      
      shr     edx, 17                       ; Bit 16 into Carry
      rcr     ax, 1                         ; Carry -> Bit 15 of Offset
      and     eax, 0FFFEFFFFh               ; Kill Bit 16 in EAX
     Is8bitChannel:
      movzx   dx, [esi+PDMAslotStruc.PortAddress]
      out     dx, al
      shr     eax, 8
      out     dx, al                     ; Set Physical Address (WORD)

      movzx   dx, [esi+PDMAslotStruc.PortPage]
      shr     eax, 8
      out     dx, al                     ; Set Page

      movzx   dx, [esi+PDMAslotStruc.PortLength]
      mov     ax, [esi+PDMAslotStruc.TransferLength]
      out     dx, al
      shr     ax, 8
      out     dx, al                     ; Set Length (already DMA conform)
   popf                                  ; Interruption now allowed
   movzx   dx, [esi+PDMAslotStruc.PortMask]
   mov     al, bl
   out     dx, al                        ; Unmask Channel to get it going
   ret
PDMA_StartTransfer              EndP

; Actually stops a physical DMA transfer...
PDMA_StopTransfer               Proc Near   Uses edx esi, PDMAptr:dword
   mov     esi, PDMAptr
   movzx   dx, [esi+PDMAslotStruc.PortMask]
   mov     al, [esi+PDMAslotStruc.DMAmask]
   add     al, 4
   out     dx, al                        ; Mask Channel to stop transfer
   ret
PDMA_StopTransfer               EndP

; -----------------------------------------------------------------------------

; Dont ask me from where I got that one :)
PDMA_StartVTIMERCallOut         Proc Near
   push    0
   push    1                    ; Function 1 - Start VDHCallOutDMA VTIMER calling
   push    0
   push    0
   call    VDMA_VTIMERentry
   ret
PDMA_StartVTIMERCallOut       EndP

PDMA_StopVTIMERCallOut        Proc Near
   push    0
   push    2                    ; Function 2 - Stop VDHCallOutDMA VTIMER calling
   push    0
   push    0
   call    VDMA_VTIMERentry
   ret
PDMA_StopVTIMERCallOut        EndP

; Will calculate and fill out BufferLength and LastBufferLength of PDMA-Slot
PDMA_CalcTimedTo2Buffers      Proc Near   Uses eax edx esi, PDMAptr:dword
   mov     esi, PDMAptr
   movzx   eax, [esi+PDMAslotStruc.TransferLength] ; DMA-Length (!) not bytes
   cmp     eax, 2
   jb      Underflow
   inc     eax                           ; DMA-logic: 0 means 1
   mov     edx, eax
   shr     eax, 1                        ; Length/2
   sub     edx, eax                      ; Length-BufferLength
   dec     eax                           ; Convert EAX/EDX to DMA-length again
   dec     edx
  SetBufferLengths:
   mov     [esi+PDMAslotStruc.BlockLength], ax
   mov     [esi+PDMAslotStruc.LastBlockLength], dx
   mov     [esi+PDMAslotStruc.CopyPos], 0 ; Reset CopyPos in here
   ret
  Underflow:
   mov     dx, ax
   xor     ax, ax
   jmp     SetBufferLengths
PDMA_CalcTimedTo2Buffers      EndP

; Will calculate and fill out BufferLength and LastBufferLength of PDMA-Slot
PDMA_CalcTimedTo4Buffers      Proc Near   Uses eax edx esi, PDMAptr:dword
   mov     esi, PDMAptr
   movzx   eax, [esi+PDMAslotStruc.TransferLength] ; DMA-Length (!) not bytes
   cmp     eax, 4
   jb      Underflow
   inc     eax                           ; DMA-logic: 0 means 1
   mov     edx, eax
   shr     eax, 2                        ; Length/4
   sub     edx, eax
   sub     edx, eax
   sub     edx, eax                      ; Length-(BufferLength*3)
   dec     eax                           ; Convert EAX/EDX to DMA-length again
   dec     edx
  SetBufferLengths:
   mov     [esi+PDMAslotStruc.BlockLength], ax
   mov     [esi+PDMAslotStruc.LastBlockLength], dx
   mov     [esi+PDMAslotStruc.CopyPos], 0 ; Reset CopyPos in here
   ret
  Underflow:
   mov     dx, ax
   xor     ax, ax
   jmp     SetBufferLengths
PDMA_CalcTimedTo4Buffers      EndP

; Will calculate best-fit for large transfers and fill out BufferLength and
;  LastBufferLength of PDMA-Slot. Assumes that TransferLength=>1000h (!)
PDMA_CalcTimedToBestFit         Proc Near   Uses eax ebx ecx edx esi, PDMAptr:dword
   int 3
   mov     esi, PDMAptr
   movzx   eax, [esi+PDMAslotStruc.TransferLength] ; DMA-Length (!) not bytes
   inc     eax                           ; DMA-logic: 0 means 1
   mov     ebx, eax
   mov     edx, eax                      ; EAX == EBX == EDX
   mov     ecx, 7                        ; will divide by 128
   shl     ebx, 16
   jc      BitFound
   dec     ecx                           ; will divide by 64
   shl     ebx, 1
   jc      BitFound
   dec     ecx                           ; will divide by 32
   shl     ebx, 1
   jc      BitFound
   dec     ecx                           ; at least divide by 16
  BitFound:
   cmp     [esi+VDMAslotStruc.DMAno], 4
   jb      Is8bitChannel
   dec     ecx                           ; Half the buffers on 16-bit Transfers
  Is8bitChannel:
   ; ECX - BestFit Divider
   shr     eax, cl                       ; Divide by prev calculated divider
   sub     ecx, 3                        ; 00-8,00-16,01-32,02-64,03-128
   not     ecx                           ; FF-8,FF-16,FE-32,FD-64,FC-128
   add     ecx, 14                       ; 0D-8,0C-16,0B-32,0A-64,09-128
   mov     ebx, 0000FFFFh                ; so generate
   shr     ebx, cl                       ; 0F->1F->3F->7F

   and     edx, ebx
   add     edx, eax
   dec     eax                           ; Convert EAX/EDX to DMA-length again
   dec     edx
   mov     [esi+PDMAslotStruc.BlockLength], ax
   mov     [esi+PDMAslotStruc.LastBlockLength], dx
   mov     [esi+PDMAslotStruc.CopyPos], 0 ; Reset CopyPos in here
   ret
PDMA_CalcTimedToBestFit         EndP

; Will make one Copy step, will return TRUE, if end-of-buffer reached/overflow
PDMA_ProcessOnePCopyStep        Proc Near   Uses ebx ecx edx esi, PDMAptr:dword
   mov     esi, PDMAptr
   movzx   eax, [esi+PDMAslotStruc.CopyPos]
   mov     edx, eax                      ; EDX - CopyPos (in DMA form)
   movzx   ecx, [esi+PDMAslotStruc.LastBlockLength]
   add     eax, ecx             ; AX - 
   cmp     ax, [esi+PDMAslotStruc.TransferLength]
   pushf
      jae     IsLastBlock
      mov     cx, [esi+PDMAslotStruc.BlockLength] ; use normal block length...
     IsLastBlock:
      ; (E)CX - BlockLength in DMA format, (E)DX - CopyPos in DMA format
      inc     ecx                        ; EDX stays at 0 (cause its an offset)
      mov     ebx, ecx                   ; Save BlockLength+1 in EBX
      cmp     [esi+VDMAslotStruc.DMAno], 4
      jb      Is8bitChannel
      shl     edx, 1
      shl     ecx, 1                     ; On 16-bit Channels -> WORD Size
     Is8bitChannel:
   popf
   ; ECX - Byte-Length of Block, EDX - CopyPos (byte!)
   jbe     SingleCopy
   ; We need to do 2 copies. From CopyPos to EOB and from offset 0.
   ret

  SingleCopy:
   push    ebx
      mov     eax, [esi+PDMAslotStruc.VirtualAddress] ; Source (VDM)
      add     eax, edx
      push    eax
      mov     eax, [esi+PDMAslotStruc.LinearAddress]  ; Destination (Physical)
      add     eax, edx
      push    eax
      push    ecx                                     ; Length in Bytes
      call    VDHCopyMem
   pop     ebx
   ; EBX - (BlockLength+1) <- this is *NOT* byte-length (!)

   xor     eax, eax
   mov     dx, [esi+PDMAslotStruc.CopyPos]
   add     dx, bx                ; Adjust CopyPos
   jc      CopyPosOverflow
   cmp     dx, [esi+PDMAslotStruc.TransferLength]
   jb      CopyPosNoOverflow
  CopyPosOverflow:
   inc     eax                   ; Report Overflow to caller
   xor     dx, dx                ; Reset on overflow to NULL
  CopyPosNoOverflow:
   mov     [esi+PDMAslotStruc.CopyPos], dx

   mov     dx, [esi+PDMAslotStruc.TriggerPos]
   sub     [esi+PDMAslotStruc.TriggerPos], bx
   jnc     TriggerPosNoOverflow
   mov     dx, [esi+PDMAslotStruc.TransferLength]
   mov     [esi+PDMAslotStruc.TriggerPos], dx
  TriggerPosNoOverflow:
   ret                           ; EAX is BOOL that shows if overflow occured
PDMA_ProcessOnePCopyStep      EndP

; -----------------------------------------------------------------------------
;        In: *none*
;       Out: *none*
; Destroyed: *none*
;
;      From: VPIC, VTIMER
;   Context: interrupt/task time
;  Function: Will check, if a physical DMA transfer exceeded the Trigger-Pos
;             if that's the case, it will generate a Context-Hook to the VDM
VDHCallOutDMA                   Proc Near   Uses eax ebx ecx edx esi
   pushf
      cli                                ; No interruption during DMA-GetCurPos
      ; First, reset both Flip-Flop registers
      mov     esi, offset VDMA_PDMAslots
      movzx   dx, bptr [esi+PDMAslotStruc.PortFlipFlop]
      xor     al, al
      out     dx, al
      ; Hardcoded -> points to PDMA4
      movzx   dx, bptr [esi+(PDMAslot_Length*4)+PDMAslotStruc.PortFlipFlop]
      xor     al, al
      out     dx, al

      mov     ecx, 8
     CallOutLoop:
         test    [esi+PDMAslotStruc.Flags], PDMAslot_Flags_GetsCallOut
         jz      ChannelUnmonitored
         ; Physical Slot enabled...

            ; Read the current position within DMA buffer
            movzx   dx, [esi+PDMAslotStruc.PortLength]
            in      al, dx
            mov     ah, al
            in      al, dx
            xchg    al, ah               ; AX - DMA-CurPos
            mov     [esi+PDMAslotStruc.CurLength], ax

            ; Check, if Trigger to activated...
            cmp     ax, [esi+PDMAslotStruc.TriggerPos]
            ja      SkipCopyEvent
            add     ax, [esi+PDMAslotStruc.TriggerDistance]
            jc      ExecCopyEvent
            cmp     ax, [esi+PDMAslotStruc.TriggerPos]
            jb      SkipCopyEvent
           ExecCopyEvent:
            test    [esi+PDMAslotStruc.Flags], PDMAslot_Flags_InCopyEvent
            jnz     SkipCopyEvent
            or      [esi+PDMAslotStruc.Flags], PDMAslot_Flags_InCopyEvent
            MPush   <eax,ecx,edx>        ; Some registers are destroyed by VDH
               push    [esi+PDMAslotStruc.ContextHookHndl] ;Context-Hook-Handle
               push    [esi+PDMAslotStruc.OwnedBy]         ;HVDM
               call    VDHArmContextHook
            MPop    <edx,ecx,eax>
           SkipCopyEvent:

        ChannelUnmonitored:
         add     esi, PDMAslot_Length
      loop    CallOutLoop
   popf
   ret
VDHCallOutDMA                   EndP

; These here are Context-Hooks that will occur from VDHCallOutDMA (asm/PDMA.asm)
;  on Trigger of a PDMA-Slot
PDMA_CopyEventOnDMA0:
   push    offset VDMA_PDMAslot0
   call    PDMA_CopyEvent
   add     esp, 4
   retn 8
PDMA_CopyEventOnDMA1:
   push    offset VDMA_PDMAslot1
   call    PDMA_CopyEvent
   add     esp, 4
   retn 8
PDMA_CopyEventOnDMA2:
   push    offset VDMA_PDMAslot2
   call    PDMA_CopyEvent
   add     esp, 4
   retn 8
PDMA_CopyEventOnDMA3:
   push    offset VDMA_PDMAslot3
   call    PDMA_CopyEvent
   add     esp, 4
   retn 8
PDMA_CopyEventOnDMA4:
   push    offset VDMA_PDMAslot4
   call    PDMA_CopyEvent
   add     esp, 4
   retn 8
PDMA_CopyEventOnDMA5:
   push    offset VDMA_PDMAslot5
   call    PDMA_CopyEvent
   add     esp, 4
   retn 8
PDMA_CopyEventOnDMA6:
   push    offset VDMA_PDMAslot6
   call    PDMA_CopyEvent
   add     esp, 4
   retn 8
PDMA_CopyEventOnDMA7:
   push    offset VDMA_PDMAslot7
   call    PDMA_CopyEvent
   add     esp, 4
   retn 8

; Will set PDMA-Slot CurLength and reply with AX == CurLength
PDMA_UpdateCurLength            Proc Near   Uses edx esi, PDMAptr:dword
   mov     esi, PDMAptr
   xor     eax, eax
   ; No interruption during Get-CurPos
   pushf
      cli
      movzx   dx, [esi+PDMAslotStruc.PortFlipFlop]
      xor     al, al
      out     dx, al                     ; Reset Flip-Flop
      movzx   dx, [esi+PDMAslotStruc.PortLength]
      in      al, dx
      mov     ah, al
      in      al, dx
   popf
   xchg    al, ah                        ; AX - CurLength
   mov     [esi+PDMAslotStruc.CurLength], ax

   test    [esi+PDMAslotStruc.Flags], PDMAslot_Flags_TerminalCount
   jnz     GotTerminalCount
   ; Set Terminal-Count flag, if CurPos exceeded or equal Transfer-Length
   cmp     ax, 0FFFFh
   je      GotTerminalCount
   ret

  GotTerminalCount:
   and     [esi+PDMAslotStruc.Flags], PDMAslot_Flags_TerminalCountNOT
   or      eax, 10000h          ; Set Bit 16
   ret
PDMA_UpdateCurLength            EndP
